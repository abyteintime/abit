import collections
import io
import json
from datetime import datetime

import ghidra_output

def is_valid_identifier(s: str):
    return (
        len(s) >= 1 and
        not (s[0] >= '0' and s[0] <= '9') and
        all(map(
            lambda c: (
                (c >= 'a' and c <= 'z')
                or (c >= 'A' and c <= 'Z')
                or (c >= '0' and c <= '9')
                or c == '_'
            ),
            s,
        ))
    )

def assert_valid_identifier(source: str, identifier: str):
    assert is_valid_identifier(identifier), f"generated identifier '{identifier}' (from '{source}') is not a valid C++ identifier"

def namespace_symbol_to_identifier(name: str):
    if name == "Global":
        # Let's reserve PascalCase for classes.
        return "global"
    return name

OPERATORS = {
    "+": "_operatorPlus",
    "-": "_operatorMinus",
    "*": "_operatorStar",
    "/": "_operatorDiv",
    "%": "_operatorMod",
    "^": "_operatorBitXor",
    "&": "_operatorBitAnd",
    "|": "_operatorBitOr",
    "~": "_operatorBitNot",
    "!": "_operatorNot",
    "=": "_operatorAssign",
    "<": "_operatorLess",
    ">": "_operatorGreater",
    "+=": "_operatorPlusAssign",
    "-=": "_operatorMinusAssign",
    "*=": "_operatorStarAssign",
    "/=": "_operatorDivAssign",
    "%=": "_operatorModAssign",
    "^=": "_operatorXorAssign",
    "&=": "_operatorAndAssign",
    "|=": "_operatorOrAssign",
    "<<": "_operatorShiftLeft",
    ">>": "_operatorShiftRight",
    ">>=": "_operatorShiftLeftAssign",
    "<<=": "_operatorShiftRightAssign",
    "==": "_operatorEqual",
    "!=": "_operatorNotEqual",
    "<=": "_operatorLessEqual",
    ">=": "_operatorGreaterEqual",
    "&&": "_operatorAnd",
    "||": "_operatorOr",
    "++": "_operatorIncrement",
    "--": "_operatorDecrement",
    ",": "_operatorComma",
    "->*": "_operatorArrowStar",
    "->": "_operatorArrow",
    "()": "_operatorCall",
    "[]": "_operatorIndex",
    "_delete[]": "_operatorDeleteArray",
}

def function_symbol_to_identifier(name: str, symbol: ghidra_output.Symbol, ambiguous: bool):
    out_name = name
    if name.startswith('~'):
        out_name = "_destructor"
    if name.startswith("operator"):
        out_name = OPERATORS.get(name.removeprefix("operator"), name)

    if ambiguous:
        # This is kind of bad because symbol locations change between builds of Hat.
        out_name = f"{out_name}_{symbol.location}"

    return out_name

Header = collections.namedtuple("Header", "namespace_identifier source_code")

def generate_header(namespace_name, namespace):
    builder = io.StringIO()
    builder.writelines([
        f"// Header generated by A Byte in Time Procs generator\n",
        f"// at {datetime.now()}\n",
        f"// for namespace '{namespace_name}'\n",
        "\n",
        "#pragma once\n",
        "\n",
        '#include "abit/dll_macros.hpp"\n',
        '#include "abit/procs/proc.hpp"\n',
        "\n",
    ])

    namespace_identifier = namespace_symbol_to_identifier(namespace_name)
    assert_valid_identifier(namespace_name, namespace_identifier)
    builder.write(f"namespace abit::procs::{namespace_identifier} {{\n")
    for symbol_name, overload_list in namespace.items():
        identifiers_in_scope = set()
        ambiguous = len(overload_list) > 1
        for symbol in overload_list:
            symbol_identifier = function_symbol_to_identifier(symbol_name, symbol, ambiguous)
            assert_valid_identifier(symbol_name, symbol_identifier)
            assert symbol_identifier not in identifiers_in_scope, f"duplicated identifier '{symbol_identifier}' in namespace '{namespace}'"
            identifiers_in_scope.add(symbol_identifier)
            builder.write(f"ABIT_DLL_IMPORT extern abit::Proc {symbol_identifier};\n")
    builder.write("}\n")

    return f"{namespace_identifier}.hpp", Header(namespace_identifier, source_code=builder.getvalue())

def generate_cpp(namespaces, headers):
    builder = io.StringIO()
    builder.writelines([
        f"// Source generated by A Byte in Time Procs generator\n",
        f"// at {datetime.now()}\n",
        "\n",
        '#include "abit/dll_macros.hpp"\n',
        '#include "abit/procs/proc.hpp"\n',
        "\n",
    ])

    for namespace_name, namespace in namespaces.items():
        namespace_identifier = namespace_symbol_to_identifier(namespace_name)
        builder.write(f"namespace abit::procs::{namespace_identifier} {{\n")

        for symbol_name, overload_list in namespace.items():
            ambiguous = len(overload_list) > 1
            for symbol in overload_list:
                symbol_identifier = function_symbol_to_identifier(symbol_name, symbol, ambiguous)
                quoted_symbol = json.dumps(f"{namespace_name}::{symbol.original_name}")
                location = int(symbol.location, 16) - ghidra_output.BASE_ADDRESS
                builder.write(f"ABIT_DLL_EXPORT abit::Proc {symbol_identifier}{{ {quoted_symbol}, (void*)0x{location:x} }};\n")

        builder.write("}\n\n")

    builder.write('\n')

    return builder.getvalue()