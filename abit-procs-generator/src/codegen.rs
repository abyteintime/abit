use std::{
    borrow::Cow,
    collections::HashMap,
    fmt::Write,
    hash::{Hash, Hasher},
};

use anyhow::bail;
use chrono::Utc;
use log::error;
use twox_hash::XxHash32;

use crate::pdbfile::{Namespace, Symbol, SymbolKind};

pub fn is_valid_identifier(s: &str) -> bool {
    if s.is_empty() {
        return false;
    }

    let mut chars = s.chars();
    let first = chars.next().unwrap();
    matches!(first, 'a'..='z'| 'A'..='Z' | '_')
        && chars.all(|c| matches!(c, 'a'..='z' | 'A'..='Z' | '0'..='9' | '_'))
}

fn make_valid_identifier_from_symbol(symbol: &str) -> Cow<'_, str> {
    match symbol {
        _ if symbol.starts_with('~') => "_destructor".into(),
        "operator+" => "_operatorPlus".into(),
        "operator-" => "_operatorMinus".into(),
        "operator*" => "_operatorStar".into(),
        "operator/" => "_operatorDiv".into(),
        "operator%" => "_operatorMod".into(),
        "operator^" => "_operatorBitXor".into(),
        "operator&" => "_operatorBitAnd".into(),
        "operator|" => "_operatorBitOr".into(),
        "operator~" => "_operatorBitNot".into(),
        "operator!" => "_operatorNot".into(),
        "operator=" => "_operatorAssign".into(),
        "operator<" => "_operatorLess".into(),
        "operator>" => "_operatorGreater".into(),
        "operator+=" => "_operatorPlusAssign".into(),
        "operator-=" => "_operatorMinusAssign".into(),
        "operator*=" => "_operatorStarAssign".into(),
        "operator/=" => "_operatorDivAssign".into(),
        "operator%=" => "_operatorModAssign".into(),
        "operator^=" => "_operatorXorAssign".into(),
        "operator&=" => "_operatorAndAssign".into(),
        "operator|=" => "_operatorOrAssign".into(),
        "operator<<" => "_operatorShiftLeft".into(),
        "operator>>" => "_operatorShiftRight".into(),
        "operator>>=" => "_operatorShiftLeftAssign".into(),
        "operator<<=" => "_operatorShiftRightAssign".into(),
        "operator==" => "_operatorEqual".into(),
        "operator!=" => "_operatorNotEqual".into(),
        "operator<=" => "_operatorLessEqual".into(),
        "operator>=" => "_operatorGreaterEqual".into(),
        "operator&&" => "_operatorAnd".into(),
        "operator||" => "_operatorOr".into(),
        "operator++" => "_operatorIncrement".into(),
        "operator--" => "_operatorDecrement".into(),
        "operator," => "_operatorComma".into(),
        "operator->*" => "_operatorArrowStar".into(),
        "operator->" => "_operatorArrow".into(),
        "operator()" => "_operatorCall".into(),
        "operator[]" => "_operatorIndex".into(),
        "operator new" => "_operatorNew".into(),
        "operator new[]" => "_operatorNewArray".into(),
        "operator delete" => "_operatorDelete".into(),
        "operator delete[]" => "_operatorDeleteArray".into(),
        _ if symbol.starts_with("operator ") => format!(
            "_operatorConvert_{}",
            symbol.strip_prefix("operator ").unwrap()
        )
        .into(),
        _ if symbol.starts_with("?GRegisterNative") => "GRegisterNative".into(),
        _ => symbol.into(),
    }
}

fn symbol_declaration_type(symbol_kind: SymbolKind) -> &'static str {
    match symbol_kind {
        SymbolKind::Function => "abit::Proc",
        SymbolKind::Data => "abit::Global",
    }
}

fn generate_symbol_name<'a>(
    base_name: &'a str,
    symbol: &Symbol,
    is_overloaded: bool,
) -> Cow<'a, str> {
    if is_overloaded {
        let mut hasher = XxHash32::with_seed(0x101);
        symbol.mangled_name.hash(&mut hasher);
        if symbol.kind == SymbolKind::Data {
            hasher.write_u32(symbol.address);
        }
        let hash = hasher.finish();
        format!("{base_name}_{hash:08x}").into()
    } else {
        base_name.into()
    }
}

pub fn generate_header(ns_name: &str, ns: &Namespace) -> anyhow::Result<String> {
    let mut header = String::new();

    writeln!(header, "// Header generated by abit-procs-generator")?;
    writeln!(header, "// at {}", Utc::now())?;
    writeln!(header, "// for PDB namespace '{ns_name}'")?;
    writeln!(header)?;
    writeln!(header, r#"#include "abit/procs/base.hpp""#)?;
    writeln!(header)?;

    if !is_valid_identifier(ns_name) {
        bail!("Namespace name {ns_name} is not a valid C++ identifier");
    }
    writeln!(header, "namespace abit::procs::{ns_name} {{")?;

    for (symbol_name, symbol_group) in &ns.symbols {
        for symbol in &symbol_group.overloads {
            let decl_type = symbol_declaration_type(symbol.kind);
            let symbol_name = make_valid_identifier_from_symbol(symbol_name);
            let symbol_name =
                generate_symbol_name(&symbol_name, symbol, symbol_group.is_overloaded());
            if is_valid_identifier(&symbol_name) {
                let left = format!("ABIT_DLL_IMPORT extern {decl_type} {symbol_name};");
                writeln!(header, "{left:100} // {}", symbol.full_demangled_name)?;
            } else {
                error!("In namespace {ns_name:?}: {symbol_name:?} is not a valid C++ identifier");
            }
        }
    }

    writeln!(header, "}}")?;

    Ok(header)
}

pub fn generate_definitions(namespaces: &HashMap<String, Namespace>) -> anyhow::Result<String> {
    let mut source = String::new();

    writeln!(source, "// Definitions generated by abit-procs-generator")?;
    writeln!(source, "// at {}", Utc::now())?;
    writeln!(source)?;
    writeln!(source, r#"#include "abit/procs/base.hpp""#)?;
    writeln!(source)?;

    for (ns_name, ns) in namespaces {
        if !is_valid_identifier(ns_name) {
            // This is already caught and reported in generate_header, so don't generate an error
            // message here.
            continue;
        }

        writeln!(source, "namespace abit::procs::{ns_name} {{")?;
        for (symbol_name, symbol_group) in &ns.symbols {
            for symbol in &symbol_group.overloads {
                let decl_type = symbol_declaration_type(symbol.kind);
                let symbol_name = make_valid_identifier_from_symbol(symbol_name);
                let symbol_name =
                    generate_symbol_name(&symbol_name, symbol, symbol_group.is_overloaded());
                if is_valid_identifier(&symbol_name) {
                    let Symbol {
                        demangled_name,
                        ref address,
                        ..
                    } = symbol;
                    writeln!(
						source,
						"ABIT_DLL_EXPORT {decl_type} {symbol_name}{{ {demangled_name:?}, (void*)0x{address:x} }};"
					)?;
                }
            }
        }
        writeln!(source, "}}")?;
        writeln!(source)?;
    }

    Ok(source)
}
